name: CI / Build and Push to ECR

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read
  packages: write

env:
  IMAGE_TAG: ${{ github.sha }}
  ARGO_APP_NAME: kuber-todo
  ARGO_NAMESPACE: argocd

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          REPO: ${{ secrets.ECR_REPOSITORY }}
          TAG: ${{ env.IMAGE_TAG }}
        run: |
          docker build -t ${ECR_REGISTRY}/${REPO}:${TAG} ./backend
          docker push ${ECR_REGISTRY}/${REPO}:${TAG}

      - name: Install kubectl
        run: |
          set -e
          K8S_VERSION="v1.32.9"
          curl -fsSLo kubectl "https://dl.k8s.io/release/${K8S_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Configure kubectl for EKS
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: aws eks update-kubeconfig --name "${{ secrets.EKS_CLUSTER_NAME }}" --region "${{ secrets.AWS_REGION }}"

      - name: Helm lint and render
        run: |
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash >/dev/null
          helm lint k8s/helm/kuber-todo
          helm template k8s/helm/kuber-todo --values k8s/helm/kuber-todo/values.yaml > /tmp/rendered.yaml

      - name: Validate rendered manifests with kubeval
        run: |
          set -e
          KUBEVAL_VERSION="0.16.1"
          curl -sL "https://github.com/instrumenta/kubeval/releases/download/v${KUBEVAL_VERSION}/kubeval-linux-amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/kubeval /usr/local/bin/kubeval
          kubeval --strict --kubernetes-version "1.32.0" --ignore-missing-schemas /tmp/rendered.yaml

      # MongoDB secret management removed: secret is expected to be managed out-of-band (SealedSecrets/ExternalSecrets or manual)

      - name: Patch ArgoCD Application
        env:
          ARGO_APP_NAME: ${{ env.ARGO_APP_NAME }}
          ARGO_NAMESPACE: ${{ env.ARGO_NAMESPACE }}
          REGISTRY: ${{ env.ECR_REGISTRY }}
          REPO: ${{ secrets.ECR_REPOSITORY }}
          TAG: ${{ env.IMAGE_TAG }}
        run: |
          # We hard-code ARGO_APP_NAME/ARGO_NAMESPACE at workflow top-level env. The CI will patch only image values.
          VALUES="image:\n  repository: \"${REGISTRY}/${REPO}\"\n  tag: \"${TAG}\""
          PATCH_JSON=$(printf "%b" "$VALUES" | python3 -c 'import sys,json; v=sys.stdin.read(); print(json.dumps({"spec":{"source":{"helm":{"values":v}}}}))')
          kubectl -n "${ARGO_NAMESPACE}" patch application "${ARGO_APP_NAME}" --type merge -p "$PATCH_JSON"

      - name: Trigger ArgoCD sync (API then fallback)
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
          ARGO_APP_NAME: ${{ env.ARGO_APP_NAME }}
        run: |
          # Prefer ArgoCD API sync when credentials are provided; otherwise fall back to kubectl annotation.
          if [ -n "${ARGOCD_SERVER}" ] && [ -n "${ARGOCD_TOKEN}" ] && [ -n "${ARGO_APP_NAME}" ]; then
            echo "Attempting ArgoCD API sync"
            resp=$(curl -k -s -w "HTTPSTATUS:%{http_code}" -X POST -H "Authorization: Bearer ${ARGOCD_TOKEN}" -H "Content-Type: application/json" "${ARGOCD_SERVER}/api/v1/applications/${ARGO_APP_NAME}/sync" -d '{}' ) || true
            status=$(echo "$resp" | sed -e 's/.*HTTPSTATUS://')
            if [ -n "$resp" ] && [ -n "$status" ] && [ "$status" -ge 200 ] && [ "$status" -lt 300 ]; then
              echo "ArgoCD API sync requested (status: $status)"
            else
              echo "ArgoCD API sync missing/failed (status: ${status:-none}), falling back to kubectl annotate"
              kubectl -n argocd annotate application "${ARGO_APP_NAME}" argocd.argoproj.io/refresh="hard" --overwrite || { echo "kubectl annotate failed"; exit 1; }
            fi
          else
            echo "ArgoCD API credentials not provided; falling back to kubectl annotate"
            kubectl -n argocd annotate application "${ARGO_APP_NAME}" argocd.argoproj.io/refresh="hard" --overwrite || { echo "kubectl annotate failed"; exit 1; }
          fi

  smoke-test:
    name: Smoke test (post-deploy)
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Configure kubectl for EKS
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: aws eks update-kubeconfig --name "${{ secrets.EKS_CLUSTER_NAME }}" --region "${{ secrets.AWS_REGION }}"

      - name: Wait for ArgoCD Application to be Synced and Healthy
        env:
          ARGO_APP_NAME: ${{ env.ARGO_APP_NAME }}
        run: |
          if [ -z "${ARGO_APP_NAME}" ]; then echo "ARGOCD_APP_NAME must be set"; exit 1; fi
          timeout=$((10*60))
          interval=5
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            sync=$(kubectl -n argocd get applications.argoproj.io ${ARGO_APP_NAME} -o jsonpath='{.status.sync.status}' 2>/dev/null || true)
            health=$(kubectl -n argocd get applications.argoproj.io ${ARGO_APP_NAME} -o jsonpath='{.status.health.status}' 2>/dev/null || true)
            if [ "$sync" = 'Synced' ] && [ "$health" = 'Healthy' ]; then
              break
            fi
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          if [ $elapsed -ge $timeout ]; then
            kubectl -n argocd get applications.argoproj.io ${ARGO_APP_NAME} -o yaml || true
            exit 1
          fi

      - name: Discover application host
        env:
          NAMESPACE: ${{ secrets.K8S_NAMESPACE }}
        run: |
          if [ -z "$NAMESPACE" ]; then NAMESPACE=kuber-todo; fi
          HOST=$(kubectl -n $NAMESPACE get ingress -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || true)
          if [ -z "$HOST" ]; then
            HOST=$(kubectl -n $NAMESPACE get svc -l app.kubernetes.io/name=kuber-todo -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
          fi
          if [ -z "$HOST" ]; then
            HOST=$(kubectl -n $NAMESPACE get svc -l app.kubernetes.io/name=kuber-todo -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
          fi
          if [ -z "$HOST" ]; then exit 1; fi
          echo "APPLICATION_HOST=$HOST" >> $GITHUB_ENV

      - name: Run HTTP smoke tests
        run: |
          HOST="$APPLICATION_HOST"
          if curl -sSf "http://$HOST/api/todo" -o /dev/null; then
            exit 0
          elif curl -sSf "https://$HOST/api/todo" -o /dev/null -k; then
            exit 0
          else
            exit 1
          fi
